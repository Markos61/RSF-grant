# -*- coding: cp1251 -*-
##
import torch
from torch.nn.functional import softmax


def analyze_tonality(text, tokenizer, model, predict=False):
    """
    Функция для получения тональности предложения
    :param predict: вкл/выкл
    :param tokenizer: Токенайзер;
    :param model: Модель для получения тональности;
    :param text: Текущее предложение
    :return: Строка с названием тональности
    """
    if not predict:
        return 'Тональность'
    else:
        inputs = tokenizer(text, return_tensors="pt", truncation=True, padding=True)
        with torch.no_grad():
            logits = model(**inputs).logits
        probs = softmax(logits, dim=1).numpy()[0]
        labels = ['negative', 'neutral', 'positive']
        sentiment_result = dict(zip(labels, probs.tolist()))
        predicted_sentiment = max(sentiment_result, key=sentiment_result.get)
        return predicted_sentiment


def analyze_modality(text, predict=False):
    """
    Функция для получения тональности предложения
    :param predict: вкл/выкл
    :param text: Текущее предложение
    :return: Строка с названием тональности
    """
    if not predict:
        return 'Модальность'
    else:
        modality_dict = {
            "Постановка вопроса": ['?'],
            "Обязанность": [
                "нужно", "надо", "следует", "обязан", "обязаны", "должен", "должны", "должна", 'должно',
                "требуется", "необходимо", "надлежит", "полагается", "предписано",
                "следует рассматривать", "обязательство", "неотъемлемо", "следует учитывать",
                "необходимо учитывать", "обязано", "обязательность", "непременно",
                "обязаны соблюдать", "обязаны выполнять", "требуется выполнение",
                "должен быть", "должно быть", "следует выполнять", "необходимо выполнить",
                "надлежит сделать", "следует сделать", "обязано выполнить", "обязано сделать",
                "должно соблюдаться", "следует соблюдать", "обязаны соблюдать", 'будем', 'будет'
            ],
            "Возможность": [
                "можно", "возможно", "способен", "способны", "имеет возможность",
                "есть шанс", "допускается", "не исключено", "позволено", "разрешается",
                "вероятно", "скорее всего", "вряд ли", "может быть", "имеется возможность",
                "есть вероятность", "допустимо", "возможно", "с вероятностью",
                "возможность", "можно попробовать", "имеет шанс", "есть вероятность того",
                "разрешено", "допускается выполнение",
                "есть шанс того", "могло бы быть", "думаю"
            ],
            "Желательность": [
                "хочу", "хотелось бы", "хотели", "желательно", "мечтаю", "стоит", "следовало бы",
                "неплохо бы", "бы хорошо", "было бы здорово", "предпочтительно", "лучше бы",
                "рекомендую", "целесообразно", "оптимально", "предпочтительнее", "желали"
                                                                                 "целесообразно сделать",
                "желательно сделать", "рекомендовано", "желательно учитывать",
                "лучше всего", "желательно соблюдать", "желаемо", "хотелось бы видеть",
                "следовало бы учитывать", "желательно выполнять", "полезно бы", "неплохо бы сделать",
                "хотелось бы иметь", "лучше", "предпочтительно выполнять", "желательно иметь",
                "желательно учитывать при", "стоило бы", "было бы неплохо"
            ]
        }

        modality_counts = {"Постановка вопроса": 0, "Обязанность": 0, "Возможность": 0, "Желательность": 0}
        for category, words in modality_dict.items():
            for w in words:
                if w in text.lower():
                    modality_counts[category] += 1

        max_value = max(modality_counts.values())
        max_categories = [k for k, v in modality_counts.items() if v == max_value]

        if len(max_categories) == 3:
            return "Нейтральная"

        elif len(max_categories) == 2:
            return f"{max_categories[0]}/{max_categories[1]}"
        else:
            return max_categories[0]
